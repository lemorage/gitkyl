use anyhow::{Context, Result};
use gitkyl::Config;
use maud::{DOCTYPE, Markup, html};
use std::fs;

/// Generates index page HTML.
fn index_page(
    name: &str,
    owner: &Option<String>,
    default_branch: &str,
    branches: &[String],
    commit_count: usize,
) -> Markup {
    html! {
        (DOCTYPE)
        html lang="en" {
            head {
                meta charset="utf-8";
                meta name="viewport" content="width=device-width, initial-scale=1.0";
                title { (name) " - Gitkyl" }
                style {
                    "* { margin: 0; padding: 0; box-sizing: border-box; }"
                    "body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Helvetica, Arial, sans-serif; line-height: 1.6; color: #24292f; background: #ffffff; padding: 2rem; }"
                    ".container { max-width: 1200px; margin: 0 auto; }"
                    "header { border-bottom: 1px solid #d0d7de; padding-bottom: 1rem; margin-bottom: 2rem; }"
                    "h1 { font-size: 2rem; font-weight: 600; margin-bottom: 0.5rem; }"
                    ".owner { color: #57606a; font-size: 1.25rem; }"
                    ".stats { display: flex; gap: 2rem; margin: 2rem 0; padding: 1rem; background: #f6f8fa; border-radius: 6px; }"
                    ".stat { display: flex; flex-direction: column; }"
                    ".stat-label { font-size: 0.875rem; color: #57606a; }"
                    ".stat-value { font-size: 1.5rem; font-weight: 600; color: #24292f; }"
                    ".branches { margin-top: 2rem; }"
                    ".branches h2 { font-size: 1.5rem; margin-bottom: 1rem; }"
                    ".branch-list { list-style: none; border: 1px solid #d0d7de; border-radius: 6px; overflow: hidden; }"
                    ".branch-item { padding: 0.75rem 1rem; border-bottom: 1px solid #d0d7de; }"
                    ".branch-item:last-child { border-bottom: none; }"
                    ".branch-item.default { background: #ddf4ff; font-weight: 600; }"
                    ".branch-name { color: #0969da; }"
                    ".default-badge { display: inline-block; padding: 0.125rem 0.5rem; background: #1f883d; color: white; font-size: 0.75rem; border-radius: 12px; margin-left: 0.5rem; }"
                    "footer { margin-top: 3rem; padding-top: 2rem; border-top: 1px solid #d0d7de; text-align: center; color: #57606a; font-size: 0.875rem; }"
                    "footer a { color: #0969da; text-decoration: none; }"
                    "footer a:hover { text-decoration: underline; }"
                }
            }
            body {
                div class="container" {
                    header {
                        @if let Some(owner_name) = owner {
                            div class="owner" { (owner_name) }
                        }
                        h1 { (name) }
                    }
                    div class="stats" {
                        div class="stat" {
                            span class="stat-label" { "Default Branch" }
                            span class="stat-value" { (default_branch) }
                        }
                        div class="stat" {
                            span class="stat-label" { "Branches" }
                            span class="stat-value" { (branches.len()) }
                        }
                        div class="stat" {
                            span class="stat-label" { "Commits" }
                            span class="stat-value" { (commit_count) }
                        }
                    }
                    section class="branches" {
                        h2 { "Branches" }
                        ul class="branch-list" {
                            @for branch in branches {
                                li class={"branch-item" @if branch == default_branch { " default" }} {
                                    span class="branch-name" { (branch) }
                                    @if branch == default_branch {
                                        span class="default-badge" { "default" }
                                    }
                                }
                            }
                        }
                    }
                    footer {
                        p {
                            "Generated by "
                            a href="https://github.com/lemorage/gitkyl" target="_blank" { "Gitkyl" }
                        }
                    }
                }
            }
        }
    }
}

fn main() -> Result<()> {
    let config = Config::parse();
    config.validate().context("Invalid configuration")?;

    let repo_info = gitkyl::analyze_repository(&config.repo, config.owner.clone())
        .context("Failed to analyze repository")?;

    fs::create_dir_all(&config.output).context("Failed to create output directory")?;

    let html = index_page(
        &config
            .project_name()
            .context("Failed to determine project name")?,
        &repo_info.owner().map(ToOwned::to_owned),
        repo_info.default_branch(),
        repo_info.branches(),
        repo_info.commit_count(),
    );

    let index_path = config.output.join("index.html");
    fs::write(&index_path, html.into_string()).context("Failed to write index.html")?;

    println!("Generated: {}", index_path.display());

    let files = gitkyl::list_files(&config.repo, Some(repo_info.default_branch()))
        .context("Failed to list repository files")?;

    let mut generated_count = 0;
    for entry in &files {
        if let Some(path) = entry.path() {
            let Some(path_str) = path.to_str() else {
                eprintln!(
                    "Warning: Skipping file with invalid UTF-8 path: {}",
                    path.display()
                );
                continue;
            };

            match gitkyl::generate_blob_page(&config.repo, repo_info.default_branch(), path) {
                Ok(html) => {
                    let blob_dir = config.output.join("blob");

                    let safe_path = path_str.replace('/', "_");
                    let blob_path = blob_dir.join(format!("{}.html", safe_path));

                    if let Some(parent) = blob_path.parent() {
                        fs::create_dir_all(parent).context("Failed to create blob directory")?;
                    }

                    fs::write(&blob_path, html.into_string()).with_context(|| {
                        format!("Failed to write blob page {}", blob_path.display())
                    })?;

                    generated_count += 1;
                }
                Err(e) => {
                    let err_msg = e.to_string();
                    if err_msg.contains("not a blob") || err_msg.contains("invalid UTF8") {
                        continue;
                    }
                    return Err(e).with_context(|| {
                        format!("Failed to generate blob page for {}", path.display())
                    });
                }
            }
        }
    }

    println!("Generated {} file pages", generated_count);

    Ok(())
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_index_page_basic_structure() {
        // Arrange
        let name = "TestRepo";
        let owner = None;
        let default_branch = "main";
        let branches = vec!["main".to_string(), "develop".to_string()];
        let commit_count = 42;

        // Act
        let html = index_page(name, &owner, default_branch, &branches, commit_count);
        let html_string = html.into_string();

        // Assert
        assert!(html_string.contains("TestRepo"));
        assert!(html_string.contains("main"));
        assert!(html_string.contains("develop"));
        assert!(html_string.contains("42"));
        assert!(html_string.contains("Gitkyl"));
    }

    #[test]
    fn test_index_page_with_owner() {
        // Arrange
        let name = "MyProject";
        let owner = Some("lemorage".to_string());
        let default_branch = "master";
        let branches = vec!["master".to_string()];
        let commit_count = 100;

        // Act
        let html = index_page(name, &owner, default_branch, &branches, commit_count);
        let html_string = html.into_string();

        // Assert
        assert!(html_string.contains("MyProject"));
        assert!(html_string.contains("lemorage"));
        assert!(html_string.contains("master"));
        assert!(html_string.contains("100"));
    }

    #[test]
    fn test_index_page_multiple_branches() {
        // Arrange
        let name = "MultiBranch";
        let owner = None;
        let default_branch = "main";
        let branches = vec![
            "main".to_string(),
            "feature-a".to_string(),
            "feature-b".to_string(),
            "hotfix".to_string(),
        ];
        let commit_count = 250;

        // Act
        let html = index_page(name, &owner, default_branch, &branches, commit_count);
        let html_string = html.into_string();

        // Assert
        assert!(html_string.contains("main"));
        assert!(html_string.contains("feature-a"));
        assert!(html_string.contains("feature-b"));
        assert!(html_string.contains("hotfix"));
        assert!(html_string.contains("default"));
    }

    #[test]
    fn test_index_page_default_branch_badge() {
        // Arrange
        let name = "BadgeTest";
        let owner = None;
        let default_branch = "develop";
        let branches = vec!["main".to_string(), "develop".to_string()];
        let commit_count = 10;

        // Act
        let html = index_page(name, &owner, default_branch, &branches, commit_count);
        let html_string = html.into_string();

        // Assert
        assert!(html_string.contains("develop"));
        assert!(html_string.contains("default-badge"));
    }
}
