use anyhow::{Context, Result};
use gitkyl::Config;
use maud::{DOCTYPE, Markup, html};
use std::fs;

/// Generates index page HTML.
fn index_page(
    name: &str,
    owner: &Option<String>,
    default_branch: &str,
    branches: &[String],
    commit_count: usize,
) -> Markup {
    html! {
        (DOCTYPE)
        html lang="en" {
            head {
                meta charset="utf-8";
                meta name="viewport" content="width=device-width, initial-scale=1.0";
                title { (name) " - Gitkyl" }
                style {
                    (include_str!("../assets/index.css"))
                }
            }
            body {
                div class="container" {
                    header {
                        @if let Some(owner_name) = owner {
                            div class="owner" { (owner_name) }
                        }
                        h1 { (name) }
                    }
                    div class="stats" {
                        div class="stat" {
                            span class="stat-label" { "Default Branch" }
                            span class="stat-value" { (default_branch) }
                        }
                        div class="stat" {
                            span class="stat-label" { "Branches" }
                            span class="stat-value" { (branches.len()) }
                        }
                        div class="stat" {
                            span class="stat-label" { "Commits" }
                            span class="stat-value" { (commit_count) }
                        }
                    }
                    section class="branches" {
                        h2 { "Branches" }
                        ul class="branch-list" {
                            @for branch in branches {
                                li class={"branch-item" @if branch == default_branch { " default" }} {
                                    span class="branch-name" { (branch) }
                                    @if branch == default_branch {
                                        span class="default-badge" { "default" }
                                    }
                                }
                            }
                        }
                    }
                    footer {
                        p {
                            "Generated by "
                            a href="https://github.com/lemorage/gitkyl" target="_blank" { "Gitkyl" }
                        }
                    }
                }
            }
        }
    }
}

fn main() -> Result<()> {
    let config = Config::parse();
    config.validate().context("Invalid configuration")?;

    let repo_info = gitkyl::analyze_repository(&config.repo, config.owner.clone())
        .context("Failed to analyze repository")?;

    fs::create_dir_all(&config.output).context("Failed to create output directory")?;

    let html = index_page(
        &config
            .project_name()
            .context("Failed to determine project name")?,
        &repo_info.owner().map(ToOwned::to_owned),
        repo_info.default_branch(),
        repo_info.branches(),
        repo_info.commit_count(),
    );

    let index_path = config.output.join("index.html");
    fs::write(&index_path, html.into_string()).context("Failed to write index.html")?;

    println!("Generated: {}", index_path.display());

    let files = gitkyl::list_files(&config.repo, Some(repo_info.default_branch()))
        .context("Failed to list repository files")?;

    let mut generated_count = 0;
    for entry in &files {
        if let Some(path) = entry.path() {
            if path.to_str().is_none() {
                eprintln!(
                    "Warning: Skipping file with invalid UTF-8 path: {}",
                    path.display()
                );
                continue;
            }

            match gitkyl::generate_blob_page(&config.repo, repo_info.default_branch(), path) {
                Ok(html) => {
                    let blob_path = config
                        .output
                        .join("blob")
                        .join(repo_info.default_branch())
                        .join(path)
                        .with_extension("html");

                    if let Some(parent) = blob_path.parent() {
                        fs::create_dir_all(parent).context("Failed to create blob directory")?;
                    }

                    fs::write(&blob_path, html.into_string()).with_context(|| {
                        format!("Failed to write blob page {}", blob_path.display())
                    })?;

                    generated_count += 1;
                }
                Err(e) => {
                    let err_msg = format!("{:?}", e);
                    if err_msg.contains("not a blob") || err_msg.contains("invalid UTF8") {
                        continue;
                    }
                    return Err(e).with_context(|| {
                        format!("Failed to generate blob page for {}", path.display())
                    });
                }
            }
        }
    }

    println!("Generated {} file pages", generated_count);

    Ok(())
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_index_page_basic_structure() {
        // Arrange
        let name = "TestRepo";
        let owner = None;
        let default_branch = "main";
        let branches = vec!["main".to_string(), "develop".to_string()];
        let commit_count = 42;

        // Act
        let html = index_page(name, &owner, default_branch, &branches, commit_count);
        let html_string = html.into_string();

        // Assert
        assert!(html_string.contains("TestRepo"));
        assert!(html_string.contains("main"));
        assert!(html_string.contains("develop"));
        assert!(html_string.contains("42"));
        assert!(html_string.contains("Gitkyl"));
    }

    #[test]
    fn test_index_page_with_owner() {
        // Arrange
        let name = "MyProject";
        let owner = Some("lemorage".to_string());
        let default_branch = "master";
        let branches = vec!["master".to_string()];
        let commit_count = 100;

        // Act
        let html = index_page(name, &owner, default_branch, &branches, commit_count);
        let html_string = html.into_string();

        // Assert
        assert!(html_string.contains("MyProject"));
        assert!(html_string.contains("lemorage"));
        assert!(html_string.contains("master"));
        assert!(html_string.contains("100"));
    }

    #[test]
    fn test_index_page_multiple_branches() {
        // Arrange
        let name = "MultiBranch";
        let owner = None;
        let default_branch = "main";
        let branches = vec![
            "main".to_string(),
            "feature-a".to_string(),
            "feature-b".to_string(),
            "hotfix".to_string(),
        ];
        let commit_count = 250;

        // Act
        let html = index_page(name, &owner, default_branch, &branches, commit_count);
        let html_string = html.into_string();

        // Assert
        assert!(html_string.contains("main"));
        assert!(html_string.contains("feature-a"));
        assert!(html_string.contains("feature-b"));
        assert!(html_string.contains("hotfix"));
        assert!(html_string.contains("default"));
    }

    #[test]
    fn test_index_page_default_branch_badge() {
        // Arrange
        let name = "BadgeTest";
        let owner = None;
        let default_branch = "develop";
        let branches = vec!["main".to_string(), "develop".to_string()];
        let commit_count = 10;

        // Act
        let html = index_page(name, &owner, default_branch, &branches, commit_count);
        let html_string = html.into_string();

        // Assert
        assert!(html_string.contains("develop"));
        assert!(html_string.contains("default-badge"));
    }
}
