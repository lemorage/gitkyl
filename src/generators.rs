//! HTML page generators for repository content.

use anyhow::{Context, Result};
use maud::{DOCTYPE, Markup, PreEscaped, html};
use std::path::Path;

use crate::git::read_blob;
use crate::highlight::highlight;

/// Generates HTML blob page with syntax highlighting.
///
/// Reads blob content from the repository at the specified reference and path,
/// applies tree-sitter syntax highlighting, and renders as HTML with line numbers.
/// The output follows GitHub's visual design patterns.
///
/// # Arguments
///
/// * `repo_path`: Path to git repository
/// * `ref_name`: Git reference (branch/tag/commit)
/// * `file_path`: File path within repository tree
///
/// # Returns
///
/// HTML markup ready for writing to disk
///
/// # Errors
///
/// Returns error if:
/// - Blob cannot be read from repository
/// - File content contains invalid UTF8
/// - Syntax highlighting fails
///
/// # Examples
///
/// ```no_run
/// use gitkyl::generate_blob_page;
/// use std::path::Path;
///
/// let html = generate_blob_page(
///     Path::new("."),
///     "main",
///     Path::new("src/lib.rs")
/// )?;
/// # Ok::<(), anyhow::Error>(())
/// ```
pub fn generate_blob_page(
    repo_path: impl AsRef<Path>,
    ref_name: &str,
    file_path: impl AsRef<Path>,
) -> Result<Markup> {
    let content_bytes = read_blob(&repo_path, Some(ref_name), &file_path)
        .context("Failed to read blob from repository")?;

    let content = String::from_utf8(content_bytes).context("Blob contains invalid UTF8")?;

    let highlighted =
        highlight(&content, file_path.as_ref()).context("Failed to apply syntax highlighting")?;

    let path_str = file_path.as_ref().display().to_string();
    let path_components = extract_breadcrumb_components(&path_str);

    Ok(blob_page_markup(
        &path_str,
        &path_components,
        ref_name,
        &highlighted,
    ))
}

/// Extracts breadcrumb path components from file path.
fn extract_breadcrumb_components(path: &str) -> Vec<&str> {
    path.split('/').filter(|s| !s.is_empty()).collect()
}

/// Renders blob page HTML structure.
fn blob_page_markup(
    file_path: &str,
    breadcrumb_components: &[&str],
    ref_name: &str,
    highlighted_code: &str,
) -> Markup {
    let lines: Vec<&str> = highlighted_code.lines().collect();
    let line_count = lines.len().max(1);

    html! {
        (DOCTYPE)
        html lang="en" {
            head {
                meta charset="utf-8";
                meta name="viewport" content="width=device-width, initial-scale=1.0";
                title { (file_path) " - Gitkyl" }
                style {
                    (style_blob_page())
                }
            }
            body {
                div class="container" {
                    header {
                        div class="breadcrumb" {
                            a href="/" class="breadcrumb-link" { "Repository" }
                            @for (idx, component) in breadcrumb_components.iter().enumerate() {
                                span class="breadcrumb-separator" { "/" }
                                @if idx == breadcrumb_components.len() - 1 {
                                    span class="breadcrumb-current" { (*component) }
                                } @else {
                                    span class="breadcrumb-link" { (*component) }
                                }
                            }
                        }
                        div class="ref-info" {
                            span class="ref-label" { "ref: " }
                            span class="ref-name" { (ref_name) }
                        }
                    }
                    main class="blob-container" {
                        div class="line-numbers" {
                            @for line_num in 1..=line_count {
                                div class="line-number" { (line_num) }
                            }
                        }
                        div class="code-content" {
                            pre {
                                code {
                                    @for line in lines {
                                        div class="code-line" {
                                            (PreEscaped(line))
                                        }
                                    }
                                }
                            }
                        }
                    }
                    footer {
                        p {
                            "Generated by "
                            a href="https://github.com/lemorage/gitkyl" target="_blank" { "Gitkyl" }
                        }
                    }
                }
            }
        }
    }
}

/// CSS styles for blob page.
fn style_blob_page() -> &'static str {
    r#"
* { margin: 0; padding: 0; box-sizing: border-box; }
body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Helvetica, Arial, sans-serif; line-height: 1.6; color: #24292f; background: #ffffff; }
.container { max-width: 1400px; margin: 0 auto; padding: 2rem; }
header { border-bottom: 1px solid #d0d7de; padding-bottom: 1rem; margin-bottom: 2rem; }
.breadcrumb { font-size: 1rem; margin-bottom: 0.5rem; }
.breadcrumb-link { color: #0969da; text-decoration: none; }
.breadcrumb-link:hover { text-decoration: underline; }
.breadcrumb-separator { color: #57606a; margin: 0 0.25rem; }
.breadcrumb-current { font-weight: 600; color: #24292f; }
.ref-info { font-size: 0.875rem; color: #57606a; }
.ref-label { font-weight: 400; }
.ref-name { font-family: ui-monospace, SFMono-Regular, 'SF Mono', Menlo, Consolas, monospace; background: #f6f8fa; padding: 0.125rem 0.5rem; border-radius: 3px; color: #24292f; }
.blob-container { display: flex; border: 1px solid #d0d7de; border-radius: 6px; overflow: hidden; background: #ffffff; }
.line-numbers { background: #f6f8fa; padding: 0.75rem 0.5rem; text-align: right; user-select: none; border-right: 1px solid #d0d7de; min-width: 3.5rem; }
.line-number { font-family: ui-monospace, SFMono-Regular, 'SF Mono', Menlo, Consolas, monospace; font-size: 0.875rem; line-height: 1.5; color: #57606a; }
.code-content { flex: 1; overflow-x: auto; }
pre { margin: 0; padding: 0.75rem 1rem; }
code { font-family: ui-monospace, SFMono-Regular, 'SF Mono', Menlo, Consolas, monospace; font-size: 0.875rem; line-height: 1.5; display: block; }
.code-line { min-height: 1.5em; }
.hl-comment { color: #6e7781; }
.hl-string { color: #0a3069; }
.hl-number { color: #0550ae; }
.hl-keyword { color: #cf222e; }
.hl-type { color: #8250df; }
.hl-function { color: #8250df; }
.hl-variable { color: #24292f; }
.hl-property { color: #24292f; }
.hl-operator { color: #cf222e; }
.hl-punctuation { color: #24292f; }
footer { margin-top: 3rem; padding-top: 2rem; border-top: 1px solid #d0d7de; text-align: center; color: #57606a; font-size: 0.875rem; }
footer a { color: #0969da; text-decoration: none; }
footer a:hover { text-decoration: underline; }
"#
}

#[cfg(test)]
mod tests {
    use super::*;
    use std::path::PathBuf;

    #[test]
    fn test_extract_breadcrumb_components_simple() {
        // Arrange
        let path = "src/main.rs";

        // Act
        let components = extract_breadcrumb_components(path);

        // Assert
        assert_eq!(components, vec!["src", "main.rs"]);
    }

    #[test]
    fn test_extract_breadcrumb_components_nested() {
        // Arrange
        let path = "src/generators/html.rs";

        // Act
        let components = extract_breadcrumb_components(path);

        // Assert
        assert_eq!(components, vec!["src", "generators", "html.rs"]);
    }

    #[test]
    fn test_extract_breadcrumb_components_single() {
        // Arrange
        let path = "README.md";

        // Act
        let components = extract_breadcrumb_components(path);

        // Assert
        assert_eq!(components, vec!["README.md"]);
    }

    #[test]
    fn test_extract_breadcrumb_components_empty() {
        // Arrange
        let path = "";

        // Act
        let components = extract_breadcrumb_components(path);

        // Assert
        assert!(components.is_empty());
    }

    #[test]
    fn test_blob_page_markup_structure() {
        // Arrange
        let file_path = "src/lib.rs";
        let breadcrumb = vec!["src", "lib.rs"];
        let ref_name = "main";
        let code = "<span class=\"hl-keyword\">fn</span> main() {}";

        // Act
        let html = blob_page_markup(file_path, &breadcrumb, ref_name, code);
        let html_string = html.into_string();

        // Assert
        assert!(html_string.contains("src/lib.rs"));
        assert!(html_string.contains("main"));
        assert!(html_string.contains("hl-keyword"));
        assert!(html_string.contains("Repository"));
        assert!(html_string.contains("Gitkyl"));
    }

    #[test]
    fn test_blob_page_markup_breadcrumb() {
        // Arrange
        let file_path = "tests/integration/test.rs";
        let breadcrumb = vec!["tests", "integration", "test.rs"];
        let ref_name = "develop";
        let code = "test code";

        // Act
        let html = blob_page_markup(file_path, &breadcrumb, ref_name, code);
        let html_string = html.into_string();

        // Assert
        assert!(html_string.contains("tests"));
        assert!(html_string.contains("integration"));
        assert!(html_string.contains("test.rs"));
        assert!(html_string.contains("breadcrumb-separator"));
    }

    #[test]
    fn test_blob_page_markup_ref_info() {
        // Arrange
        let file_path = "config.toml";
        let breadcrumb = vec!["config.toml"];
        let ref_name = "feature/new-parser";
        let code = "content";

        // Act
        let html = blob_page_markup(file_path, &breadcrumb, ref_name, code);
        let html_string = html.into_string();

        // Assert
        assert!(html_string.contains("ref:"));
        assert!(html_string.contains("feature/new-parser"));
        assert!(html_string.contains("ref-name"));
    }

    #[test]
    fn test_blob_page_markup_line_numbers() {
        // Arrange
        let file_path = "test.rs";
        let breadcrumb = vec!["test.rs"];
        let ref_name = "main";
        let code = "line 1\nline 2\nline 3";

        // Act
        let html = blob_page_markup(file_path, &breadcrumb, ref_name, code);
        let html_string = html.into_string();

        // Assert
        assert!(html_string.contains("line-number"));
        assert!(html_string.contains("line 1"));
        assert!(html_string.contains("line 2"));
        assert!(html_string.contains("line 3"));
    }

    #[test]
    fn test_blob_page_markup_empty_code() {
        // Arrange
        let file_path = "empty.txt";
        let breadcrumb = vec!["empty.txt"];
        let ref_name = "main";
        let code = "";

        // Act
        let html = blob_page_markup(file_path, &breadcrumb, ref_name, code);
        let html_string = html.into_string();

        // Assert
        assert!(html_string.contains("empty.txt"));
        assert!(html_string.contains("blob-container"));
    }

    #[test]
    fn test_blob_page_markup_single_line() {
        // Arrange
        let file_path = "single.txt";
        let breadcrumb = vec!["single.txt"];
        let ref_name = "main";
        let code = "single line";

        // Act
        let html = blob_page_markup(file_path, &breadcrumb, ref_name, code);
        let html_string = html.into_string();

        // Assert
        assert!(html_string.contains("single line"));
        assert!(html_string.contains("line-number"));
    }

    #[test]
    fn test_generate_blob_page_integration() {
        // Arrange
        let repo_path = PathBuf::from(env!("CARGO_MANIFEST_DIR"));
        let ref_name = "HEAD";
        let file_path = Path::new("Cargo.toml");

        // Act
        let result = generate_blob_page(&repo_path, ref_name, file_path);

        // Assert
        assert!(
            result.is_ok(),
            "Should generate blob page for existing file"
        );
        let html = result.unwrap().into_string();
        assert!(html.contains("Cargo.toml"));
        assert!(html.contains("blob-container"));
    }

    #[test]
    fn test_generate_blob_page_rust_syntax() {
        // Arrange
        let repo_path = PathBuf::from(env!("CARGO_MANIFEST_DIR"));
        let ref_name = "HEAD";
        let file_path = Path::new("src/lib.rs");

        // Act
        let result = generate_blob_page(&repo_path, ref_name, file_path);

        // Assert
        assert!(
            result.is_ok(),
            "Should generate blob page with syntax highlighting"
        );
        let html = result.unwrap().into_string();
        assert!(html.contains("src/lib.rs"));
        assert!(
            html.contains("hl-") || html.contains("line-number"),
            "Should contain highlighting or line numbers"
        );
    }

    #[test]
    fn test_generate_blob_page_nonexistent_file() {
        // Arrange
        let repo_path = PathBuf::from(env!("CARGO_MANIFEST_DIR"));
        let ref_name = "HEAD";
        let file_path = Path::new("nonexistent_file_12345.txt");

        // Act
        let result = generate_blob_page(&repo_path, ref_name, file_path);

        // Assert
        assert!(result.is_err(), "Should fail for nonexistent file");
    }

    #[test]
    fn test_generate_blob_page_invalid_ref() {
        // Arrange
        let repo_path = PathBuf::from(env!("CARGO_MANIFEST_DIR"));
        let ref_name = "invalid_ref_that_does_not_exist_12345";
        let file_path = Path::new("Cargo.toml");

        // Act
        let result = generate_blob_page(&repo_path, ref_name, file_path);

        // Assert
        assert!(result.is_err(), "Should fail for invalid reference");
    }

    #[test]
    fn test_style_blob_page_contains_classes() {
        // Arrange & Act
        let css = style_blob_page();

        // Assert
        assert!(css.contains(".blob-container"));
        assert!(css.contains(".line-numbers"));
        assert!(css.contains(".code-content"));
        assert!(css.contains(".hl-keyword"));
        assert!(css.contains(".hl-string"));
        assert!(css.contains(".breadcrumb"));
    }
}
