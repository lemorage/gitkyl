//! Component tests for Gitkyl.
//!
//! Tests UI components for correct HTML generation and content.

use gitkyl::CommitInfo;
use gitkyl::components::commit::{attribution, commit_hash};
use gitkyl::components::file_list::{file_row, file_table};
use gitkyl::components::footer::footer;
use gitkyl::components::layout::page_wrapper;
use maud::html;

#[test]
fn test_attribution_simple_case() {
    let commit = CommitInfo::new(
        "abc1234def5678".to_string(),
        "Test commit".to_string(),
        "Test commit".to_string(),
        "lemorage".to_string(),
        1234567890,
    );

    let html = attribution(&commit).into_string();

    assert!(html.contains("lemorage"));
    assert!(!html.contains("attribution-indicator"));
}

#[test]
fn test_commit_hash_contains_short_and_full() {
    let hash = "a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0";

    let html = commit_hash(hash).into_string();

    assert!(html.contains("a1b2c3d"));
    assert!(html.contains("data-full"));
    assert!(html.contains(hash));
}

#[test]
fn test_commit_hash_short_input() {
    let hash = "abc12";

    let html = commit_hash(hash).into_string();

    assert!(html.contains("abc12"));
}

#[test]
fn test_attribution_handles_special_characters() {
    let commit = CommitInfo::new(
        "abc1234".to_string(),
        "Test".to_string(),
        "Test".to_string(),
        "Müller".to_string(),
        1234567890,
    );

    let html = attribution(&commit).into_string();

    assert!(html.contains("Müller"));
}

#[test]
fn test_page_wrapper_includes_footer_component() {
    let body = html! { p { "test content" } };
    let html = page_wrapper("Test", &[], body).into_string();

    assert!(
        html.contains("Generated by"),
        "Page wrapper must include footer with 'Generated by' text"
    );
    assert!(
        html.contains("Gitkyl"),
        "Page wrapper must include footer with 'Gitkyl' link"
    );
}

#[test]
fn test_footer_html_structure_valid() {
    let html = footer().into_string();

    assert!(html.contains("<footer>"), "Footer must have footer tag");
    assert!(html.contains("</footer>"), "Footer must close footer tag");
    assert!(html.contains("<p>"), "Footer must have paragraph tag");
    assert!(html.contains("</p>"), "Footer must close paragraph tag");
    assert!(html.contains("</a>"), "Footer must close anchor tag");
}

// Breadcrumb navigation tests

#[test]
fn test_breadcrumb_root_only() {
    use gitkyl::components::nav::breadcrumb;

    let result = breadcrumb("myrepo", "../index.html", &[], "main");
    let html = result.into_string();

    assert!(html.contains("class=\"breadcrumb\""));
    assert!(html.contains("href=\"../index.html\""));
    assert!(html.contains("myrepo"));
    assert!(html.contains("ref: "));
    assert!(html.contains("main"));
}

#[test]
fn test_breadcrumb_single_component_current() {
    use gitkyl::components::nav::breadcrumb;

    let components = vec![("README.md", None)];
    let result = breadcrumb("myrepo", "../index.html", &components, "main");
    let html = result.into_string();

    assert!(html.contains("breadcrumb-separator"));
    assert!(html.contains("breadcrumb-current"));
    assert!(html.contains("README.md"));
}

#[test]
fn test_breadcrumb_nested_with_links() {
    use gitkyl::components::nav::breadcrumb;

    let components = vec![
        ("src", Some("tree/main/src.html".to_string())),
        ("lib.rs", None),
    ];
    let result = breadcrumb("myrepo", "../index.html", &components, "develop");
    let html = result.into_string();

    assert!(html.contains("href=\"tree/main/src.html\""));
    assert!(html.contains("breadcrumb-link"));
    assert!(html.contains("src"));
    assert!(html.contains("breadcrumb-current"));
    assert!(html.contains("lib.rs"));
    assert!(html.contains("develop"));
}

#[test]
fn test_breadcrumb_separator_count() {
    use gitkyl::components::nav::breadcrumb;

    let components = vec![
        ("a", Some("tree/main/a.html".to_string())),
        ("b", Some("tree/main/a/b.html".to_string())),
        ("c", None),
    ];
    let result = breadcrumb("repo", "index.html", &components, "master");
    let html = result.into_string();

    let separator_count = html.matches("breadcrumb-separator").count();
    assert_eq!(separator_count, 3);
}

#[test]
fn test_breadcrumb_current_is_last() {
    use gitkyl::components::nav::breadcrumb;

    let components = vec![
        ("dir1", Some("tree/main/dir1.html".to_string())),
        ("dir2", Some("tree/main/dir1/dir2.html".to_string())),
        ("file.rs", None),
    ];
    let result = breadcrumb("repo", "index.html", &components, "main");
    let html = result.into_string();

    let current_pos = html.find("breadcrumb-current").unwrap();
    let file_pos = html.find("file.rs").unwrap();
    assert!(current_pos < file_pos);
    assert!(html[file_pos..].contains("file.rs"));
}

#[test]
fn test_breadcrumb_ref_info_structure() {
    use gitkyl::components::nav::breadcrumb;

    let result = breadcrumb("myrepo", "index.html", &[], "feature/awesome");
    let html = result.into_string();

    assert!(html.contains("class=\"ref-info\""));
    assert!(html.contains("class=\"ref-label\""));
    assert!(html.contains("class=\"ref-name\""));
    assert!(html.contains("feature/awesome"));
}

#[test]
fn test_extract_breadcrumb_components_empty() {
    use gitkyl::components::nav::extract_breadcrumb_components;

    let result = extract_breadcrumb_components("");

    assert_eq!(result, Vec::<&str>::new());
}

#[test]
fn test_extract_breadcrumb_components_single() {
    use gitkyl::components::nav::extract_breadcrumb_components;

    let result = extract_breadcrumb_components("README.md");

    assert_eq!(result, vec!["README.md"]);
}

#[test]
fn test_extract_breadcrumb_components_nested() {
    use gitkyl::components::nav::extract_breadcrumb_components;

    let result = extract_breadcrumb_components("src/pages/blob.rs");

    assert_eq!(result, vec!["src", "pages", "blob.rs"]);
}

#[test]
fn test_extract_breadcrumb_components_no_leading_slash() {
    use gitkyl::components::nav::extract_breadcrumb_components;

    let result = extract_breadcrumb_components("/src/main.rs");

    assert_eq!(result, vec!["src", "main.rs"]);
    assert!(!result[0].starts_with('/'));
}

#[test]
fn test_extract_breadcrumb_components_no_trailing_slash() {
    use gitkyl::components::nav::extract_breadcrumb_components;

    let result = extract_breadcrumb_components("src/lib/");

    assert_eq!(result, vec!["src", "lib"]);
    assert!(!result.last().unwrap().ends_with('/'));
}

#[test]
fn test_extract_breadcrumb_components_deep_nesting() {
    use gitkyl::components::nav::extract_breadcrumb_components;

    let result = extract_breadcrumb_components("a/b/c/d/e/f.txt");

    assert_eq!(result, vec!["a", "b", "c", "d", "e", "f.txt"]);
    assert_eq!(result.len(), 6);
}

#[test]
fn test_file_table_wraps_rows_in_container() {
    let test_rows = html! {
        div { "Test row 1" }
        div { "Test row 2" }
    };

    let result = file_table(test_rows);
    let html_output = result.into_string();

    assert!(html_output.contains("<div class=\"file-table\">"));
}

#[test]
fn test_file_table_includes_row_content() {
    let test_rows = html! {
        span { "Expected content from rows" }
    };

    let result = file_table(test_rows);
    let html_output = result.into_string();

    assert!(html_output.contains("Expected content from rows"));
}

#[test]
fn test_file_table_with_empty_rows() {
    let empty_rows = html! {};

    let result = file_table(empty_rows);
    let html_output = result.into_string();

    assert!(html_output.contains("file-table"));
    assert!(!html_output.is_empty());
}

#[test]
fn test_file_row_contains_href_link() {
    let test_icon = html! { i class="ph-fill ph-file" {} };
    let commit = CommitInfo::new(
        "abc1234def5678".to_string(),
        "Initial commit".to_string(),
        "Initial commit: add main.rs with basic structure".to_string(),
        "lemorage".to_string(),
        1734393600,
    );

    let result = file_row(
        "/repo/blob/main/src/main.rs",
        test_icon,
        "main.rs",
        Some(&commit),
        "2025-12-17",
    );
    let html_output = result.into_string();

    assert!(html_output.contains("href=\"/repo/blob/main/src/main.rs\""));
}

#[test]
fn test_file_row_contains_file_row_class() {
    let test_icon = html! { i class="ph-fill ph-file" {} };
    let commit = CommitInfo::new(
        "abc1234".to_string(),
        "Update docs".to_string(),
        "Update documentation".to_string(),
        "lemorage".to_string(),
        1734307200,
    );

    let result = file_row(
        "/repo/main/README.md",
        test_icon,
        "README.md",
        Some(&commit),
        "2025-12-16",
    );
    let html_output = result.into_string();

    assert!(html_output.contains("class=\"file-row\""));
}

#[test]
fn test_file_row_contains_file_name() {
    let test_icon = html! { i class="ph-fill ph-folder" {} };
    let commit = CommitInfo::new(
        "abc1234".to_string(),
        "Add source directory".to_string(),
        "Add source directory structure".to_string(),
        "lemorage".to_string(),
        1734220800,
    );

    let result = file_row(
        "/repo/tree/main/src/",
        test_icon,
        "src/",
        Some(&commit),
        "2025-12-15",
    );
    let html_output = result.into_string();

    assert!(html_output.contains("src/"));
    assert!(html_output.contains("file-name-cell"));
}

#[test]
fn test_file_row_contains_commit_message() {
    let test_icon = html! { i class="ph-fill ph-file" {} };
    let commit = CommitInfo::new(
        "abc1234".to_string(),
        "Fix configuration defaults".to_string(),
        "Fix configuration defaults for production deployment".to_string(),
        "lemorage".to_string(),
        1734134400,
    );

    let result = file_row(
        "/repo/blob/dev/config.toml",
        test_icon,
        "config.toml",
        Some(&commit),
        "2025-12-14",
    );
    let html_output = result.into_string();

    assert!(html_output.contains("Fix configuration defaults"));
    assert!(html_output.contains("commit-message"));
}

#[test]
fn test_file_row_contains_commit_date() {
    let test_icon = html! { i class="ph-fill ph-file" {} };
    let commit = CommitInfo::new(
        "abc1234".to_string(),
        "Add BSD-3-Clause license".to_string(),
        "Add BSD-3-Clause license file".to_string(),
        "lemorage".to_string(),
        1734048000,
    );

    let result = file_row(
        "/repo/blob/main/LICENSE",
        test_icon,
        "LICENSE",
        Some(&commit),
        "2025-12-13",
    );
    let html_output = result.into_string();

    assert!(html_output.contains("2025-12-13"));
    assert!(html_output.contains("commit-date"));
}

#[test]
fn test_file_row_contains_icon_markup() {
    let test_icon = html! {
        div class="icon-box" {
            i class="ph-fill ph-file-rs icon-rust" {}
        }
    };
    let commit = CommitInfo::new(
        "abc1234".to_string(),
        "Implement core logic".to_string(),
        "Implement core library logic with tests".to_string(),
        "lemorage".to_string(),
        1733961600,
    );

    let result = file_row(
        "/repo/blob/main/lib.rs",
        test_icon,
        "lib.rs",
        Some(&commit),
        "2025-12-12",
    );
    let html_output = result.into_string();

    assert!(html_output.contains("icon-box"));
    assert!(html_output.contains("ph-fill ph-file-rs"));
}

#[test]
fn test_file_row_has_title_with_author_info() {
    let test_icon = html! { i class="ph-fill ph-file" {} };
    let commit = CommitInfo::new(
        "abc1234def5678901234567890123456789012".to_string(),
        "Add comprehensive tests".to_string(),
        "Add comprehensive test suite covering edge cases".to_string(),
        "lemorage".to_string(),
        1733875200,
    );

    let result = file_row(
        "/repo/blob/feature/test.rs",
        test_icon,
        "test.rs",
        Some(&commit),
        "2025-12-11",
    );
    let html_output = result.into_string();

    assert!(html_output.contains("title="));
    assert!(html_output.contains("lemorage"));
}

#[test]
fn test_file_row_proper_html_structure() {
    let test_icon = html! { i class="ph-fill ph-folder" {} };
    let commit = CommitInfo::new(
        "abc1234".to_string(),
        "Add test directory".to_string(),
        "Add test directory with initial test files".to_string(),
        "lemorage".to_string(),
        1733788800,
    );

    let result = file_row(
        "/repo/tree/main/tests/",
        test_icon,
        "tests/",
        Some(&commit),
        "2025-12-10",
    );
    let html_output = result.into_string();

    assert!(html_output.starts_with("<a"));
    assert!(html_output.contains("<div class=\"file-name-cell\">"));
    assert!(html_output.contains("<div class=\"commit-message\""));
    assert!(html_output.contains("<div class=\"commit-date\">"));
    assert!(html_output.ends_with("</a>"));
}

#[test]
fn test_file_row_handles_special_characters_in_filename() {
    let test_icon = html! { i class="ph-fill ph-file" {} };
    let commit = CommitInfo::new(
        "abc1234".to_string(),
        "Update versioned file".to_string(),
        "Update versioned file with new features".to_string(),
        "lemorage".to_string(),
        1733702400,
    );

    let result = file_row(
        "/repo/blob/main/my-file_v2.0.rs",
        test_icon,
        "my-file_v2.0.rs",
        Some(&commit),
        "2025-12-09",
    );
    let html_output = result.into_string();

    assert!(html_output.contains("my-file_v2.0.rs"));
}

#[test]
fn test_file_row_handles_long_commit_messages() {
    let test_icon = html! { i class="ph-fill ph-file" {} };
    let long_message = "This is a very long commit message that describes in detail all the changes that were made to the file including implementation details and reasoning";
    let commit = CommitInfo::new(
        "abc1234".to_string(),
        long_message.to_string(),
        long_message.to_string(),
        "lemorage".to_string(),
        1733616000,
    );

    let result = file_row(
        "/repo/blob/main/complex.rs",
        test_icon,
        "complex.rs",
        Some(&commit),
        "2025-12-08",
    );
    let html_output = result.into_string();

    assert!(html_output.contains(long_message));
}

#[test]
fn test_file_row_handles_unicode_in_filenames() {
    let test_icon = html! { i class="ph-fill ph-file" {} };
    let commit = CommitInfo::new(
        "abc1234".to_string(),
        "Add Chinese readme".to_string(),
        "Add Chinese language documentation".to_string(),
        "lemorage".to_string(),
        1733529600,
    );

    let result = file_row(
        "/repo/blob/main/README_中文.md",
        test_icon,
        "README_中文.md",
        Some(&commit),
        "2025-12-07",
    );
    let html_output = result.into_string();

    assert!(html_output.contains("README_中文.md"));
}

#[test]
fn test_file_table_and_file_row_integration() {
    let test_icon = html! { i class="ph-fill ph-file" {} };
    let commit1 = CommitInfo::new(
        "abc1234".to_string(),
        "First commit".to_string(),
        "First commit message".to_string(),
        "lemorage".to_string(),
        1733443200,
    );
    let commit2 = CommitInfo::new(
        "def5678".to_string(),
        "Second commit".to_string(),
        "Second commit message".to_string(),
        "lemorage".to_string(),
        1733356800,
    );

    let row1 = file_row(
        "/repo/blob/main/file1.rs",
        test_icon.clone(),
        "file1.rs",
        Some(&commit1),
        "2025-12-06",
    );

    let row2 = file_row(
        "/repo/blob/main/file2.rs",
        test_icon,
        "file2.rs",
        Some(&commit2),
        "2025-12-05",
    );

    let combined_rows = html! {
        (row1)
        (row2)
    };

    let result = file_table(combined_rows);
    let html_output = result.into_string();

    assert!(html_output.contains("file-table"));
    assert!(html_output.contains("file1.rs"));
    assert!(html_output.contains("file2.rs"));
    assert!(html_output.contains("First commit"));
    assert!(html_output.contains("Second commit"));
}

#[test]
fn test_file_row_none_commit_shows_empty_message() {
    let test_icon = html! { i class="ph-fill ph-folder" {} };

    let result = file_row("/repo/tree/main/parent/", test_icon, "..", None, "");
    let html_output = result.into_string();

    assert!(html_output.contains("class=\"file-row\""));
    assert!(html_output.contains(".."));
    assert!(!html_output.contains("title="));
}

#[test]
fn test_repo_header_with_owner_contains_separator() {
    use gitkyl::components::metadata::{RepoHeaderData, repo_header};

    let html = repo_header(RepoHeaderData {
        name: "gitkyl",
        owner: Some("lemorage"),
        tag_count: 0,
        tags_href: None,
    });
    let html_str = html.into_string();

    assert!(
        html_str.contains(" / "),
        "Header with owner should contain slash separator"
    );
}

#[test]
fn test_repo_header_with_owner_contains_both_names() {
    use gitkyl::components::metadata::{RepoHeaderData, repo_header};

    let html = repo_header(RepoHeaderData {
        name: "linux",
        owner: Some("torvalds"),
        tag_count: 0,
        tags_href: None,
    });
    let html_str = html.into_string();

    assert!(
        html_str.contains("torvalds"),
        "Header should contain owner name"
    );
    assert!(
        html_str.contains("linux"),
        "Header should contain repository name"
    );
}

#[test]
fn test_repo_header_without_owner_displays_only_repo() {
    use gitkyl::components::metadata::{RepoHeaderData, repo_header};

    let html = repo_header(RepoHeaderData {
        name: "gitkyl",
        owner: None,
        tag_count: 0,
        tags_href: None,
    });
    let html_str = html.into_string();

    assert!(
        html_str.contains("gitkyl"),
        "Header should contain repository name"
    );
}

#[test]
fn test_repo_header_without_owner_no_separator() {
    use gitkyl::components::metadata::{RepoHeaderData, repo_header};

    let html = repo_header(RepoHeaderData {
        name: "linux",
        owner: None,
        tag_count: 0,
        tags_href: None,
    });
    let html_str = html.into_string();

    assert!(
        !html_str.contains(" / "),
        "Header without owner should not contain slash separator"
    );
}

#[test]
fn test_repo_header_contains_proper_html_structure() {
    use gitkyl::components::metadata::{RepoHeaderData, repo_header};

    let html = repo_header(RepoHeaderData {
        name: "gitkyl",
        owner: Some("lemorage"),
        tag_count: 0,
        tags_href: None,
    });
    let html_str = html.into_string();

    assert!(
        html_str.contains("<header"),
        "Should contain header element"
    );
    assert!(html_str.contains("<h1"), "Should contain h1 element");
    assert!(
        html_str.contains("repo-header"),
        "Should contain repo-header class"
    );
}

#[test]
fn test_branch_selector_single_branch_shows_static_badge() {
    use gitkyl::components::metadata::branch_selector;

    let branches = &["main"];
    let current = "main";
    let min_for_selector = 2;

    let html = branch_selector(branches, current, min_for_selector, 0);
    let html_str = html.into_string();

    assert!(
        html_str.contains("branch-info"),
        "Should contain branch-info div for static badge"
    );
}

#[test]
fn test_branch_selector_single_branch_contains_name() {
    use gitkyl::components::metadata::branch_selector;

    let branches = &["develop"];
    let current = "develop";
    let min_for_selector = 3;

    let html = branch_selector(branches, current, min_for_selector, 0);
    let html_str = html.into_string();

    assert!(html_str.contains("develop"), "Should display branch name");
}

#[test]
fn test_branch_selector_single_branch_no_dropdown_icon() {
    use gitkyl::components::metadata::branch_selector;

    let branches = &["main"];
    let current = "main";
    let min_for_selector = 2;

    let html = branch_selector(branches, current, min_for_selector, 0);
    let html_str = html.into_string();

    assert!(
        !html_str.contains("ph-caret-down"),
        "Static badge should not contain dropdown arrow icon"
    );
}

#[test]
fn test_branch_selector_multiple_branches_shows_dropdown() {
    use gitkyl::components::metadata::branch_selector;

    let branches = &["main", "develop", "feature/auth"];
    let current = "main";
    let min_for_selector = 2;

    let html = branch_selector(branches, current, min_for_selector, 0);
    let html_str = html.into_string();

    assert!(
        html_str.contains("ph-caret-down"),
        "Dropdown should contain caret icon"
    );
}

#[test]
fn test_branch_selector_multiple_branches_contains_all_names() {
    use gitkyl::components::metadata::branch_selector;

    let branches = &["main", "develop", "feature/auth"];
    let current = "develop";
    let min_for_selector = 2;

    let html = branch_selector(branches, current, min_for_selector, 0);
    let html_str = html.into_string();

    assert!(html_str.contains("main"), "Should contain main branch");
    assert!(
        html_str.contains("develop"),
        "Should contain develop branch"
    );
    assert!(
        html_str.contains("feature/auth"),
        "Should contain feature/auth branch"
    );
}

#[test]
fn test_branch_selector_marks_current_branch_active() {
    use gitkyl::components::metadata::branch_selector;

    let branches = &["main", "develop", "staging"];
    let current = "develop";
    let min_for_selector = 2;

    let html = branch_selector(branches, current, min_for_selector, 0);
    let html_str = html.into_string();

    assert!(
        html_str.contains("branch-active"),
        "Current branch should have branch-active class"
    );

    let develop_index = html_str.find("develop").expect("develop should exist");
    let active_index = html_str
        .find("branch-active")
        .expect("branch-active should exist");

    assert!(
        active_index < develop_index && develop_index < active_index + 50,
        "branch-active class should appear before and near develop branch name"
    );
}

#[test]
fn test_branch_selector_multiple_branches_has_dropdown_icon() {
    use gitkyl::components::metadata::branch_selector;

    let branches = &["main", "hotfix/security"];
    let current = "main";
    let min_for_selector = 2;

    let html = branch_selector(branches, current, min_for_selector, 0);
    let html_str = html.into_string();

    assert!(
        html_str.contains("ph-caret-down"),
        "Multiple branches should trigger dropdown with icon"
    );
    assert!(
        html_str.contains("branch-caret"),
        "Caret should have branch-caret class"
    );
}

#[test]
fn test_branch_selector_threshold_exactly_at_min() {
    use gitkyl::components::metadata::branch_selector;

    let branches = &["main", "develop"];
    let current = "main";
    let min_for_selector = 2;

    let html = branch_selector(branches, current, min_for_selector, 0);
    let html_str = html.into_string();

    assert!(
        html_str.contains("ph-caret-down"),
        "Exactly min_for_selector branches should trigger dropdown"
    );
    assert!(
        html_str.contains("main") && html_str.contains("develop"),
        "Both branches should be present in dropdown"
    );
}

#[test]
fn test_branch_selector_threshold_just_below_min() {
    use gitkyl::components::metadata::branch_selector;

    let branches = &["main"];
    let current = "main";
    let min_for_selector = 2;

    let html = branch_selector(branches, current, min_for_selector, 0);
    let html_str = html.into_string();

    assert!(
        !html_str.contains("ph-caret-down"),
        "Below threshold should show static badge without dropdown icon"
    );
}

#[test]
fn test_branch_selector_realistic_branch_names() {
    use gitkyl::components::metadata::branch_selector;

    let branches = &[
        "main",
        "develop",
        "feature/user-auth",
        "hotfix/critical-bug",
        "release/v1.2.3",
    ];
    let current = "feature/user-auth";
    let min_for_selector = 3;

    let html = branch_selector(branches, current, min_for_selector, 0);
    let html_str = html.into_string();

    assert!(
        html_str.contains("feature/user-auth"),
        "Should handle realistic branch naming conventions"
    );
    assert!(
        html_str.contains("release/v1.2.3"),
        "Should handle version release branches"
    );
    assert!(
        html_str.contains("branch-active"),
        "Should mark feature/user-auth as active"
    );
}
